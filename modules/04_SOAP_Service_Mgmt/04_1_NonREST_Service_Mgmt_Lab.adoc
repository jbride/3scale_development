:scrollbar:
:data-uri:
:toc2:
:linkattrs:


== SOAP and OData Service Management Introduction Lab

.Goals

* Use Red Hat 3scale API Management's gateway to connect to SOAP web services
* Explore two SOAP solutions:
** Custom headers using Lua on NGINX to automatically map a REST request to a SOAP back end
** Camel route installed in Red Hat JBoss Fuse Integration Services to route a REST request from 3scale API Management's gateway to a SOAP web service endpoint
* Use 3scale API Management's gateway to connect to OData services


.Prerequisites
* Completion of previous labs of this course
* `EXTERNAL_HOST` and `OCP_WILDCARD_DOMAIN` environment variables set in your shell
+
TIP: To check if your shell still has these environment variables set, run the `echo $EXTERNAL_HOST` and `echo $OCP_WILDCARD_DOMAIN` commands. If the variables are no longer set, return to the first lab in this course and follow the steps there to set them again.

* 3scale Admin Portal URL and user credentials to log in
+
IMPORTANT: The URL for your lab environment is `https://$OCP_PROJECT_PREFIX-3scale-admin.$OCP_WILDCARD_DOMAIN`. The userID/password is `admin/admin`.

* Red Hat OpenShift Container Platform administration URL and userID/password.
+
IMPORTANT: The OpenShift URL for your lab environment is `https://$EXTERNAL_HOST:8443/`. The userID/password for development is `developer/developer`, and the userID/password for administration is `admin/admin`.


:numbered:

== SOAP Service Management

=== Overview

In this lab you expose an existing SOAP-based JEE application running on a JBoss Enterprise Application Platform (EAP) container in the same OpenShift cluster. To do this, you use two different methods:

* Create custom modifications to Lua and NGINX configuration files to automatically map a REST request to a SOAP back end
* Deploy a JBoss Fuse Integration Services application to OpenShift, which is configured to expose it as a REST service


=== SOAP Request Using Lua and NGINX Customization

In the previous module, a custom module for Lua was written using Red Hat 3scale API Management to include SOAP headers and add basic routing of a request to a SOAP API endpoint. The reference below shows how this was done.

.Reference
* link:http://middlewareblog.redhat.com/2017/08/30/integrating-soap-based-web-services-into-red-hat-3scale-api-management/["Integrating SOAP-Based Web Services into Red Hat 3scale APIÂ Management^"]


=== SOAP Request Using JBoss Fuse Integration Services

In this section you expose an existing SOAP-based JEE application running on a JBoss EAP container in the same OpenShift cluster. To do this, you deploy a JBoss Fuse Integration Services application to OpenShift, which is configured to expose it as a REST service. This REST endpoint is provided as the back-end API for the APIcast gateway.

==== Deploy the Stores Web Service to OpenShift

. Inspect the SOAP service code:

* In this section you study the `Stores` web service interface and implementation.

.. Open the file ``$HOME/lab/3scale_development_labs/Stores/src/main/resources/wsdl`.
.. Inspect the `Stores` web service definition:
+
[source,xml]
-----
  <wsdl:portType name="Stores">
    <wsdl:operation name="getAllStores">
      <wsdl:input message="tns:getAllStoresRequest"/>
      <wsdl:output message="tns:getAllStoresResponse"/>
    </wsdl:operation>
    <wsdl:operation name="getStore">
    	<wsdl:input message="tns:getStoreRequest"></wsdl:input>
    	<wsdl:output message="tns:getStoreResponse"></wsdl:output>
    </wsdl:operation>
    <wsdl:operation name="createStore">
    	<wsdl:input message="tns:createStoreRequest"></wsdl:input>
    	<wsdl:output message="tns:createStoreResponse"></wsdl:output>
    </wsdl:operation>
    <wsdl:operation name="deleteStore">
    	<wsdl:input message="tns:deleteStoreRequest"></wsdl:input>
    	<wsdl:output message="tns:deleteStoreResponse"></wsdl:output>
    </wsdl:operation>
  </wsdl:portType>
-----

.. Open the file `$HOME/lab/3scale_development_labs/Stores/src/main/java/com/redhat/service/StoresWS.java`.
.. Inspect the SOAP web service implementation:
+
[source,java]
-----
@WebService(endpointInterface="com.redhat.service.Stores")
public class StoresWS implements Stores {

        @Inject
        StoreDao storeDAO;

        @Override
        public String createStore(Store store) {
                store = new Store(store.getStoreName(),store.getStoreLat(),store.getStoreLong());
                storeDAO.createStore(store);
                return "Store ID:" + store.getStoreID() + " CREATED";
        }

        @Override
        public String deleteStore(int storeID) {
                storeDAO.deleteStore(storeID);
                return "Store ID: " + storeID + " DELETED";
        }

        @Override
        public Store getStore(int storeID) {
                return storeDAO.getStoreById(storeID);
        }

        @Override
        public StoresType getAllStores() {
                StoresType st = new StoresType();
                st.store = storeDAO.getAll();
                return st;
        }

}
-----

* This service can be deployed on JBoss EAP and hosted on your shared OpenShift environment.

. Deploy the `Stores` web service to OpenShift:
+
IMPORTANT: When executing commands using the `oc` utility, you must be logged in to the master API of your OpenShift environment with your `OCP_USER_ID` credentials.

.. At the shell prompt of your VM, verify that you are using the `jboss` user.
.. Create a new project for your Stores API business service applications:
+
[source,text]
-----
$ oc new-project $OCP_PROJECT_PREFIX-stores-api \
     --display-name="Stores API" \
     --description="Stores API SOAP Services"
-----

.. If you are not already there, change to this new project:
+
[source,text]
-----
$ oc project $OCP_PROJECT_PREFIX-stores-api
-----
+
.. Import the `stores-api` template into your OpenShift environment:
+
[source,text]
-----
$ oc create -f 
$HOME/lab/3scale_development_labs/templates/stores-api.json
-----

.. Create the new application using the `stores-api` template:
+
[source,text]
-----
$ oc new-app --template=stores-soap --param HOSTNAME_HTTP=stores-api-$OCP_PROJECT_PREFIX.$OCP_WILDCARD_DOMAIN
-----

.. Wait a few minutes for the SOAP service to be deployed and for pods to be started, and then run this command:
+
[source,text]
-----
$ oc get pods
NAME                  READY     STATUS      RESTARTS   AGE
stores-soap-1-jnjrb   1/1       Running     0          2m
storesdb-1-6z5lx      1/1       Running     0          12m
-----


. Test the `Stores` API SOAP service:

.. In a web browser, navigate to the Stores Web Services Description Language (WSDL): `http://<<your stores api route>>/StoresWS?wsdl`
+
IMPORTANT: `<<your stores api route>>` is the hostname defined during the deployment.

* Expect to see the WSDL in the response:
+
image::images/3scale_amp_stores_api_8.png[]

.. In a new browser tab or window, open the URL link:http://wsdlbrowser.com["http://wsdlbrowser.com^"].
.. Provide the URL of the Stores WSDL and click *Browse*.
.. Check that the WSDL is imported successfully and that the list of functions is displayed on the page:
+
image::images/3scale_amp_stores_api_9.png[]

.. Click *getAllStores* to generate a sample request for the operation, and then click *Call function*.

* Expect a response similar to the following:
+
image::images/3scale_amp_stores_api_11.png[]

==== Deploy `stores fis` Project to OpenShift

IMPORTANT: When running commands using the `oc` utility, you must be logged in to the master API of your OpenShift environment with your `OCP_USER_ID` credentials.

. At the shell prompt of your VM, verify that you are using the `jboss` user.
. If you are not already there, change to this new project:
+
[source,text]
-----
$ oc project $OCP_PROJECT_PREFIX-stores-api
-----

. Import the `stores-fis` template to your OpenShift environment:
+
[source,text]
-----
$ oc create -f 
$HOME/lab/3scale_development_labs/templates/stores-fis.json
-----

. Create a new application using the `stores-fis` template:
+
[source,text]
-----
$ oc new-app --template=stores-fis --param ROUTE_HOST=stores-fis-$OCP_PROJECT_PREFIX.$OCP_WILDCARD_DOMAIN
-----

. Wait a few minutes for the `fis` service to be deployed and for the pods to be started:
+
[source,text]
-----
$ oc get pods
NAME                  READY     STATUS      RESTARTS   AGE
stores-fis-1-ff256    1/1       Running     0          35m
stores-soap-1-jnjrb   1/1       Running     0          1h
storesdb-1-6z5lx      1/1       Running     0          1h
-----


. Examine the Camel route:

.. Log in to the OpenShift administration console from a web browser using your login credentials.
.. Navigate to the `Stores API` project.
.. Click the *Stores-FIS* pod, and then click *Open Java Console*:
+
image::images/3scale_amp_stores_api_13.png[]
+
.. Click *Route Diagram*.
* Expect to see all of the Camel routes defined:
+
image::images/3scale_amp_stores_api_14.png[]

.. Alternatively, click *Source* and look into the Camel route:
* A REST route is exposed to provide HTTP methods and URLs for the different SOAP operations provided by the Stores API:
+
[source,xml]
-----
    <route id="route1" rest="true">
        <from uri="rest:post::store?routeId=route1&amp;componentName=servlet&amp;inType=com.redhat.service.CreateStore&amp;outType=com.redhat.service.CreateStoreResponse&amp;consumes=application%2Fjson"/>
        <restBinding component="servlet" consumes="application/json" id="restBinding1" outType="com.redhat.service.CreateStoreResponse" type="com.redhat.service.CreateStore"/>
        <to customId="true" id="route1" uri="direct:createStore"/>
    </route>
    <route id="route2" rest="true">
        <from uri="rest:delete::store/{storeID}?routeId=route2&amp;componentName=servlet&amp;outType=com.redhat.service.DeleteStoreResponse"/>
        <restBinding component="servlet" id="restBinding2" outType="com.redhat.service.DeleteStoreResponse"/>
        <to customId="true" id="route2" uri="direct:deleteStore"/>
    </route>
    <route id="route3" rest="true">
        <from uri="rest:get::store/{storeID}?routeId=route3&amp;produces=application%2Fjson&amp;componentName=servlet&amp;outType=com.redhat.service.GetStoreResponse"/>
        <restBinding bindingMode="json" component="servlet" id="restBinding3" outType="com.redhat.service.GetStoreResponse" produces="application/json"/>
        <to customId="true" id="route3" uri="direct:getStore"/>
    </route>
    <route id="route4" rest="true">
        <from uri="rest:get::allstores?routeId=route4&amp;produces=application%2Fjson&amp;componentName=servlet&amp;outType=com.redhat.service.StoresType"/>
        <restBinding bindingMode="json" component="servlet" id="restBinding4" outType="com.redhat.service.StoresType" produces="application/json"/>
        <to customId="true" id="route4" uri="direct:getAllStores"/>
    </route>

-----

* Note the two GET methods for `getStore` and `getAllStores`, the POST method for `postStore`, and the DELETE method for `deleteStore` operation.

* Each of the `direct` routes corresponds to the four operations defined in the REST service:
+
[source,xml]
-----
   <route customId="true" id="createStore">
        <from customId="true" id="_from1" uri="direct:createStore"/>
        <setBody customId="true" id="_setBody1">
            <simple>${body.getStore()}</simple>
        </setBody>
        <setHeader customId="true" headerName="soapMethod" id="_setHeader1">
            <constant>createStore</constant>
        </setHeader>
        <to customId="true" id="_to1" uri="direct:soap"/>
    </route>
    <route customId="true" id="deleteStore">
        <from customId="true" id="_from2" uri="direct:deleteStore"/>
        <setBody customId="true" id="_setBody2">
            <simple resultType="int">${header.storeID}</simple>
        </setBody>
        <setHeader customId="true" headerName="soapMethod" id="_setHeader2">
            <constant>deleteStore</constant>
        </setHeader>
        <to customId="true" id="_to2" uri="direct:soap"/>
    </route>
    <route customId="true" id="getStore">
        <from customId="true" id="_from3" uri="direct:getStore"/>
        <setBody customId="true" id="_setBody3">
            <simple resultType="int">${header.storeID}</simple>
        </setBody>
        <setHeader customId="true" headerName="soapMethod" id="_setHeader3">
            <constant>getStore</constant>
        </setHeader>
        <to customId="true" id="_to3" uri="direct:soap"/>
    </route>
    <route customId="true" id="getAllStores">
        <from customId="true" id="_from4" uri="direct:getAllStores"/>
        <setBody customId="true" id="_setBody4">
            <mvel>new Object[0]</mvel>
        </setBody>
        <setHeader customId="true" headerName="soapMethod" id="_setHeader4">
            <constant>getAllStores</constant>
        </setHeader>
        <to customId="true" id="_to4" uri="direct:soap"/>
    </route>
-----
** Each of the routes above gets the request, constructs the CXF request message object, and updates the header to the right `soapMethod` for calling the SOAP web service.

* A route to call the SOAP endpoint:
+
[source,xml]
-----
    <route customId="true" id="soapRoute">
        <from customId="true" id="_from5" uri="direct:soap"/>
        <toD customId="true" id="tod" uri="cxf:bean:wsStores?defaultOperationName=${header.soapMethod}&amp;exchangePattern=InOut"/>
        <setBody customId="true" id="_setBodySoap">
            <simple>${body[0]}</simple>
        </setBody>
        <setHeader customId="true" headerName="Content-Type" id="_setHeaderContextType">
            <constant>application/json</constant>
        </setHeader>
    </route>
-----

. Test the Camel REST route:

.. Send a `curl` request to the `stores-fis` route to make a call to the REST web service and check that the SOAP web service is called and that the response is converted to `application/json`:
+
[source,text]
-----
$ curl -k <<camel-rest-http route>>/allstores

-----

.. Check the response:
+
[source,text]
-----
{"store":[{"storeID":1,"storeName":"Downtown\n  Store","storeLat":-34.6052704,"storeLong":-58.3791766},{"storeID":2,"storeName":"EastSide\n  Store","storeLat":-34.5975668,"storeLong":-58.3710199}]}[sjayanti@localhost camel-webservice-fis]
-----
* You can also send sample requests to the other endpoints and ensure that there are no errors.

The REST-SOAP Camel proxy is now correctly deployed, and you can begin to configure the APIcast gateway to use this REST endpoint to communicate with the SOAP web service.


=== Use Swagger Tool to Import Documents (Optional)

* Follow the steps in the previous lab to import the API documents into 3scale API Management.

=== Create APIcast Staging and Production Routes

. Follow the steps in the API Management lab to create secure routes to the `apicast-staging` and `apicast-production` services for the Stores API.

. Verify that you are in the `3scale AMP` project:
+
[source,text]
-----
$ oc project $OCP_PROJECT_PREFIX-3scale-amp
-----

. Create new routes for the Stores API staging and production APIcast:
+
[source,text]
-----
$ oc create route edge stores-staging-route \
  --service=apicast-staging \
  --hostname=stores-staging-apicast-$OCP_PROJECT_PREFIX.$OCP_WILDCARD_DOMAIN

$ oc create route edge stores-production-route \
  --service=apicast-production \
  --hostname=stores-production-apicast-$OCP_PROJECT_PREFIX.$OCP_WILDCARD_DOMAIN
-----


=== Configure 3scale API Management


. Log in to 3scale by Red Hat's Admin Portal with your userID/password credentials.
. Create a new service:
* *Name*: `Stores API`
* *System Name*: `stores-api`
* *Description*: `Stores API`
. Create an application plan:
* *Name*: `StoresPremiumPlan`
* *System Name*: `storesPremiumPlan`
. Publish the application plan.
. In the *Developers* tab, select the *RHBank* account.
. Click *Applications* and then *Create Application*.
. Fill in the following information:
* *Application Plan*: `StoresPremiumPlan`
* *Name*: `StoresApp`
* *Description*: `Stores Application`
. In the *API* tab, click *Stores API*, and then click *Integration*.
* *Private Base URL*: URL to your JBoss Fuse Camel REST route.
* *Staging Public Base URL*: Create a new edge secure route in the `3scale_AMP` project to `stores-staging-apicast-$OCP_PROJECT_PREFIX.$OCP_WILDCARD_DOMAIN`, mapped to the `apicast-staging` service.
* *Production Public Base URL*: Create a new route in the `3scale_AMP` project to `stores-production-apicast-$OCP_PROJECT_PREFIX.$OCP_WILDCARD_DOMAIN`, mapped to the `apicast-production` service.
. Create an API Test GET request:
* *API Test GET Request*: `/allstores`
.  Click *Update and test in the Staging Environment*.
. Make a test request to the staging URL.
. Promote to production, and make a test request to the production URL:

.. Test the API by making a `curl` request to the staging URL, and check the response:
+
[source,text]
-----
$ curl -k â<<camel-stage-apicast route>>/allcustomers?user_key=<<your user_key>>â
[{"name":"redhat","address":["FuseSource Office"],"numOrders":47,"revenue":4821.0,"test":100.0,"birthDate":null,"type":"BUSINESS"}]
-----

.. Promote the API to production, test the production URL, and check the response:
+
[source,text]
-----
$ curl -k â<<camel-prod-apicast route>>/allcustomers?user_key=<<your user_key>>â
[{"name":"redhat","address":["FuseSource Office"],"numOrders":47,"revenue":4821.0,"test":100.0,"birthDate":null,"type":"BUSINESS"}]
-----

* A Camel route can be used to provide routing for 3scale API Management's gateway to the SOAP web service.

== OData Service Management

=== Introduction

In this section you deploy an OData(Open Data Protocol) service. link:http://www.odata.org/[OData^] is a standard that defines a set of best practices for building and consuming RESTful APIs. The service you deploy is based on a JBoss Data Virtualization for OpenShift Container Platform virtual database (VDB). This VDB has a virtual view that retrieves data from two database tables (MySQL and PostgreSQL) and presents them as a single SQL ANSI table. Then, out of the box, this view is exposed in JBoss Data Virtualization as an OData REST service. You can find more information here:

* link:https://www.redhat.com/en/technologies/jboss-middleware/data-virtualization[JBoss Data Virtualization^]

* link:https://access.redhat.com/documentation/en-us/red_hat_jboss_data_virtualization/6.3/html/red_hat_jboss_data_virtualization_for_openshift/[Red Hat JBoss Data Virtualization for OpenShift^].


=== Deploy `Stock API` Project to OpenShift

In this section you deploy the Stock API onto a JBoss EAP container running on OpenShift. The stock data exists in two databases: MySQL and PostgreSQL. JBoss Data Virtualization is used to provide data virtualization and present the combined data view as an OData REST service.

IMPORTANT: When executing commands using the `oc` utility, you must be logged in to the master API of your OpenShift Container Platform environment with your `OCP_USER_ID` credentials.

. At the shell prompt of your VM, verify that you are using the `jboss` user.
. Create a new project for your stock API business service applications:
+
[source,text]
-----
$ oc new-project $OCP_PROJECT_PREFIX-stock-api \
     --display-name="Stock API" \
     --description="Stock API ODATA Services"
-----

. If you are not already there, change to this new project:
+
[source,text]
-----
$ oc project $OCP_PROJECT_PREFIX-stock-api
-----
. Import the `stock-api` template to your OpenShift environment:
+
[source,text]
-----
$ oc create -f $HOME/lab/3scale_development_labs/templates/stock-api.json
-----

. Add the `datasources` environment variable secret to the project:
+
[source,text]
-----
$ oc secret new datavirt-app-config $HOME/lab/3scale_development_labs/Stock/datasources.env
-----

. Create a new service account for the `datavirt` user and provide view access:
+
[source,text]
-----
$ oc create serviceaccount datavirt-service-account
$ oc policy add-role-to-user view system:serviceaccount:stock-api:datavirt-service-account
-----

. Create the new application using the `stock-api` template:
+
[source,text]
-----
$ oc new-app --template=stock-api --param HOSTNAME_HTTP=stock-api-$OCP_PROJECT_PREFIX.$OCP_WILDCARD_DOMAIN
-----
. Test the `stock` API service deployed in your OpenShift environment:
+
[source,text]
-----
$ oc get pods
NAME                  READY     STATUS      RESTARTS   AGE
stock-api-2-34b7h     1/1       Running     0          16h
stockmysql-3-3g5v9    1/1       Running     0          18h
stockpg-5-j8181       1/1       Running     0          18h
-----

. Once the API and the database pods are running, test the `odata` service by making a request to the endpoint:
+
[source,text]
-----
$ curl -k http://stock-api-$OCP_PROJDCT_PREFIX.$OCP_WILDCARD_DOMAIN/odata4/Stock-API/FederatedStock/stock?$format=JSON
-----

* Expect a response like the following:
+
[source,JSON]
-----
{"@odata.context":"$metadata#stock","value":[{"productid":1,"amount":20.0,"storeid":1},{"productid":1,"amount":30.0,"storeid":2},{"productid":2,"amount":30.0,"storeid":1},{"productid":2,"amount":14.0,"storeid":2},{"productid":3,"amount":1.0,"storeid":1},{"productid":3,"amount":40.0,"storeid":2},{"productid":4,"amount":14.0,"storeid":1},{"productid":4,"amount":100.0,"storeid":2},{"productid":5,"amount":22.0,"storeid":1},{"productid":5,"amount":2.0,"storeid":2},{"productid":6,"amount":880.0,"storeid":1},{"productid":6,"amount":10.0,"storeid":2},{"productid":7,"amount":1200.0,"storeid":1},{"productid":7,"amount":32.0,"storeid":2},{"productid":8,"amount":532.0,"storeid":1},{"productid":8,"amount":1.0,"storeid":2},{"productid":9,"amount":10.0,"storeid":1},{"productid":9,"amount":123.0,"storeid":2},{"productid":10,"amount":1.0,"storeid":1},{"productid":10,"amount":730.0,"storeid":2}]}[sjayanti@localhost camel-webservice-fis]
-----

* The REST `odata` service is now correctly deployed, and you can now begin to configure the APIcast gateway to use this REST endpoint to communicate with the service.

=== Create APIcast Staging and Production Routes

Follow the steps in the API Management lab to create secure routes to the `apicast-staging` and `apicast-production` services for the Stock API.

. Verify that you are in the `3scale AMP` project:
+
[source,text]
-----
$ oc project $OCP_PROJECT_PREFIX-3scale-amp
-----
+
. Create new routes for the Stock API staging and production APIcast:
+
[source,text]
-----
$ oc create route edge stock-staging-route \
  --service=apicast-staging \
  --hostname=stock-staging-apicast-$OCP_PROJECT_PREFIX.$OCP_WILDCARD_DOMAIN

$ oc create route edge stock-production-route \
  --service=apicast-production \
  --hostname=stock-production-apicast-$OCP_PROJECT_PREFIX.$OCP_WILDCARD_DOMAIN
-----

=== Configure 3scale API Management

. Log in to 3scale by Red Hat's Admin Portal with your userID/password credentials.
. Create a new service:
* *Name*: `Stock API`
* *System Name*: `stock-api`
* *Description*: `Stock API`
. Create an application plan:
* *Name*: `StockPremiumPlan`
* *System Name*: `stockPremiumPlan`
. Publish the application plan.
. In the *Developers* tab, click *RHBank*.
. Click *Applications* and then click *Create Application*:
* *Application Plan*: `StockPremiumPlan`
* *Name*: `StockApp`
* *Description*: `Stock Application`
. In the *API* tab, click *Stock API* and then click *Integration*:
* *Private Base URL*: URL to your JBoss Data Virtualization route.
* *Staging Public Base URL*: Create new edge secure route in `3scale_AMP` project to `stock-staging-apicast-$OCP_PROJECT_PREFIX.$OCP_WILDCARD_DOMAIN`, mapped to the `apicast-staging` service.
* *Production Public Base URL*: Create new route in `3scale_AMP` project to `stock-prod-apicast-$OCP_PROJECT_PREFIX.$OCP_WILDCARD_DOMAIN`, mapped to the `apicast-production` service.
. Create a mapping rule:
* *Operation*: `GET`
* *Pattern*: `/odata4/Stock-API/FederatedStock/stock`
. Create API Test GET request:
* *API Test GET Request*: `/odata4/Stock-API/FederatedStock/stock?$format=JSON`
.  Click *Update and test in the Staging Environment*.
. Make a test request to the staging URL.
. Promote to production and make a test request to the production URL.
